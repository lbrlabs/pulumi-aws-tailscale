// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package bastion

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AwsBastion struct {
	pulumi.ResourceState

	// The name of the ASG that managed the bastion instances
	AsgName pulumi.StringOutput `pulumi:"asgName"`
}

// NewAwsBastion registers a new resource with the given unique name, arguments, and options.
func NewAwsBastion(ctx *pulumi.Context,
	name string, args *AwsBastionArgs, opts ...pulumi.ResourceOption) (*AwsBastion, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	if args.Route == nil {
		return nil, errors.New("invalid value for required argument 'Route'")
	}
	if args.SubnetIds == nil {
		return nil, errors.New("invalid value for required argument 'SubnetIds'")
	}
	if args.VpcId == nil {
		return nil, errors.New("invalid value for required argument 'VpcId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource AwsBastion
	err := ctx.RegisterRemoteComponentResource("tailscale-bastion:index:AwsBastion", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type awsBastionArgs struct {
	// The EC2 instance type to use for the bastion.
	InstanceType *string `pulumi:"instanceType"`
	// The AWS region you're using.
	Region string `pulumi:"region"`
	// The route you'd like to advertise via tailscale.
	Route string `pulumi:"route"`
	// The subnet Ids to launch instances in.
	SubnetIds []string `pulumi:"subnetIds"`
	// The VPC the Bastion should be created in.
	VpcId string `pulumi:"vpcId"`
}

// The set of arguments for constructing a AwsBastion resource.
type AwsBastionArgs struct {
	// The EC2 instance type to use for the bastion.
	InstanceType pulumi.StringPtrInput
	// The AWS region you're using.
	Region pulumi.StringInput
	// The route you'd like to advertise via tailscale.
	Route pulumi.StringInput
	// The subnet Ids to launch instances in.
	SubnetIds pulumi.StringArrayInput
	// The VPC the Bastion should be created in.
	VpcId pulumi.StringInput
}

func (AwsBastionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*awsBastionArgs)(nil)).Elem()
}

type AwsBastionInput interface {
	pulumi.Input

	ToAwsBastionOutput() AwsBastionOutput
	ToAwsBastionOutputWithContext(ctx context.Context) AwsBastionOutput
}

func (*AwsBastion) ElementType() reflect.Type {
	return reflect.TypeOf((**AwsBastion)(nil)).Elem()
}

func (i *AwsBastion) ToAwsBastionOutput() AwsBastionOutput {
	return i.ToAwsBastionOutputWithContext(context.Background())
}

func (i *AwsBastion) ToAwsBastionOutputWithContext(ctx context.Context) AwsBastionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AwsBastionOutput)
}

// AwsBastionArrayInput is an input type that accepts AwsBastionArray and AwsBastionArrayOutput values.
// You can construct a concrete instance of `AwsBastionArrayInput` via:
//
//	AwsBastionArray{ AwsBastionArgs{...} }
type AwsBastionArrayInput interface {
	pulumi.Input

	ToAwsBastionArrayOutput() AwsBastionArrayOutput
	ToAwsBastionArrayOutputWithContext(context.Context) AwsBastionArrayOutput
}

type AwsBastionArray []AwsBastionInput

func (AwsBastionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AwsBastion)(nil)).Elem()
}

func (i AwsBastionArray) ToAwsBastionArrayOutput() AwsBastionArrayOutput {
	return i.ToAwsBastionArrayOutputWithContext(context.Background())
}

func (i AwsBastionArray) ToAwsBastionArrayOutputWithContext(ctx context.Context) AwsBastionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AwsBastionArrayOutput)
}

// AwsBastionMapInput is an input type that accepts AwsBastionMap and AwsBastionMapOutput values.
// You can construct a concrete instance of `AwsBastionMapInput` via:
//
//	AwsBastionMap{ "key": AwsBastionArgs{...} }
type AwsBastionMapInput interface {
	pulumi.Input

	ToAwsBastionMapOutput() AwsBastionMapOutput
	ToAwsBastionMapOutputWithContext(context.Context) AwsBastionMapOutput
}

type AwsBastionMap map[string]AwsBastionInput

func (AwsBastionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AwsBastion)(nil)).Elem()
}

func (i AwsBastionMap) ToAwsBastionMapOutput() AwsBastionMapOutput {
	return i.ToAwsBastionMapOutputWithContext(context.Background())
}

func (i AwsBastionMap) ToAwsBastionMapOutputWithContext(ctx context.Context) AwsBastionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AwsBastionMapOutput)
}

type AwsBastionOutput struct{ *pulumi.OutputState }

func (AwsBastionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AwsBastion)(nil)).Elem()
}

func (o AwsBastionOutput) ToAwsBastionOutput() AwsBastionOutput {
	return o
}

func (o AwsBastionOutput) ToAwsBastionOutputWithContext(ctx context.Context) AwsBastionOutput {
	return o
}

// The name of the ASG that managed the bastion instances
func (o AwsBastionOutput) AsgName() pulumi.StringOutput {
	return o.ApplyT(func(v *AwsBastion) pulumi.StringOutput { return v.AsgName }).(pulumi.StringOutput)
}

type AwsBastionArrayOutput struct{ *pulumi.OutputState }

func (AwsBastionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AwsBastion)(nil)).Elem()
}

func (o AwsBastionArrayOutput) ToAwsBastionArrayOutput() AwsBastionArrayOutput {
	return o
}

func (o AwsBastionArrayOutput) ToAwsBastionArrayOutputWithContext(ctx context.Context) AwsBastionArrayOutput {
	return o
}

func (o AwsBastionArrayOutput) Index(i pulumi.IntInput) AwsBastionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AwsBastion {
		return vs[0].([]*AwsBastion)[vs[1].(int)]
	}).(AwsBastionOutput)
}

type AwsBastionMapOutput struct{ *pulumi.OutputState }

func (AwsBastionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AwsBastion)(nil)).Elem()
}

func (o AwsBastionMapOutput) ToAwsBastionMapOutput() AwsBastionMapOutput {
	return o
}

func (o AwsBastionMapOutput) ToAwsBastionMapOutputWithContext(ctx context.Context) AwsBastionMapOutput {
	return o
}

func (o AwsBastionMapOutput) MapIndex(k pulumi.StringInput) AwsBastionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AwsBastion {
		return vs[0].(map[string]*AwsBastion)[vs[1].(string)]
	}).(AwsBastionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AwsBastionInput)(nil)).Elem(), &AwsBastion{})
	pulumi.RegisterInputType(reflect.TypeOf((*AwsBastionArrayInput)(nil)).Elem(), AwsBastionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AwsBastionMapInput)(nil)).Elem(), AwsBastionMap{})
	pulumi.RegisterOutputType(AwsBastionOutput{})
	pulumi.RegisterOutputType(AwsBastionArrayOutput{})
	pulumi.RegisterOutputType(AwsBastionMapOutput{})
}
